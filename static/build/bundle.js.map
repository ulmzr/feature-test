{
  "version": 3,
  "sources": ["../../node_modules/malinajs/runtime.js", "../../src/client/App.xht", "../../src/client/main.js"],
  "sourcesContent": ["let __app_onerror = console.error;\n\n\nconst configure = (option) => {\n    __app_onerror = option.onerror;\n};\n\n\nconst isFunction = fn => typeof fn == 'function';\n\n\nconst safeCall = fn => {\n    try {\n        return isFunction(fn) && fn();\n    } catch (e) {\n        __app_onerror(e);\n    }\n};\n\nfunction $watch(cd, fn, callback, w) {\n    if(!w) w = {};\n    w.fn = fn;\n    w.cb = callback;\n    if(!('value' in w)) w.value = NaN;\n    cd.watchers.push(w);\n    return w;\n}\nfunction $watchReadOnly(cd, fn, callback) {\n    return $watch(cd, fn, callback, {ro: true});\n}\nfunction addEvent(cd, el, event, callback) {\n    el.addEventListener(event, callback);\n    cd_onDestroy(cd, () => {\n        el.removeEventListener(event, callback);\n    });\n}\nfunction cd_onDestroy(cd, fn) {\n    if(fn) cd._d.push(fn);\n}\nfunction $$removeItem(array, item) {\n    let i = array.indexOf(item);\n    if(i>=0) array.splice(i, 1);\n}\nfunction $ChangeDetector(parent) {\n    this.parent = parent;\n    this.children = [];\n    this.watchers = [];\n    this._d = [];\n    this.prefix = [];\n    this.$$ = parent?.$$;\n}\n$ChangeDetector.prototype.new = function() {\n    var cd = new $ChangeDetector(this);\n    this.children.push(cd);\n    return cd;\n};\n\n$ChangeDetector.prototype.destroy = function(option) {\n    if(option !== false && this.parent) $$removeItem(this.parent.children, this);\n    this.watchers.length = 0;\n    this.prefix.length = 0;\n    this._d.map(safeCall);\n    this._d.length = 0;\n    this.children.map(cd => cd.destroy(false));\n    this.children.length = 0;\n};\n\n\nconst isArray = (a) => Array.isArray(a);\n\nconst compareArray = (a, b) => {\n    let a0 = isArray(a);\n    let a1 = isArray(b);\n    if(a0 !== a1) return true;\n    if(!a0) return a !== b;\n    if(a.length !== b.length) return true;\n    for(let i=0;i<a.length;i++) {\n        if(a[i] !== b[i]) return true;\n    }\n    return false;\n};\n\n\nfunction $$compareArray(w, value) {\n    if(!compareArray(w.value, value)) return 0;\n    if(isArray(value)) w.value = value.slice();\n    else w.value = value;\n    w.cb(w.value);\n    return w.ro ? 0 : 1;\n}\n\nconst compareDeep = (a, b, lvl) => {\n    if(lvl < 0 || !a || !b) return a !== b;\n    if(a === b) return false;\n    let o0 = typeof(a) == 'object';\n    let o1 = typeof(b) == 'object';\n    if(!(o0 && o1)) return a !== b;\n\n    let a0 = isArray(a);\n    let a1 = isArray(b);\n    if(a0 !== a1) return true;\n\n    if(a0) {\n        if(a.length !== b.length) return true;\n        for(let i=0;i<a.length;i++) {\n            if(compareDeep(a[i], b[i], lvl-1)) return true;\n        }\n    } else {\n        let set = {};\n        for(let k in a) {\n            if(compareDeep(a[k], b[k], lvl-1)) return true;\n            set[k] = true;\n        }\n        for(let k in b) {\n            if(set[k]) continue;\n            return true;\n        }\n    }\n\n    return false;\n};\n\nfunction cloneDeep(d, lvl) {\n    if(lvl < 0 || !d) return d;\n\n    if(typeof(d) == 'object') {\n        if(d instanceof Date) return d;\n        if(d instanceof Element) return d;\n        if(isArray(d)) return d.map(i => cloneDeep(i, lvl-1));\n        let r = {};\n        for(let k in d) r[k] = cloneDeep(d[k], lvl-1);\n        return r;\n    }\n    return d;\n}\nconst $$cloneDeep = function(d) {\n    return cloneDeep(d, 10);\n};\n\nfunction $$deepComparator(depth) {\n    return function(w, value) {\n        let diff = compareDeep(w.value, value, depth);\n        diff && (w.value = cloneDeep(value, depth), !w.idle && w.cb(value));\n        w.idle = false;\n        return !w.ro && diff ? 1 : 0;\n    };\n}\nconst $$compareDeep = $$deepComparator(10);\n\n\nconst keyComparator = (w, value) => {\n    let diff = false;\n    for(let k in value) {\n        if(w.value[k] != value[k]) diff = true;\n        w.value[k] = value[k];\n    }\n    diff && !w.idle && w.cb(value);\n    w.idle = false;\n    return !w.ro && diff ? 1 : 0;\n};\n\n\nconst fire = w => {\n    if(w.cmp) w.cmp(w, w.fn());\n    else {\n        w.value = w.fn();\n        w.cb(w.value);\n    }\n};\n\nfunction $digest($cd) {\n    let loop = 10;\n    let w;\n    while(loop >= 0) {\n        let changes = 0;\n        let index = 0;\n        let queue = [];\n        let i, value, cd = $cd;\n        while(cd) {\n            for(i=0;i<cd.prefix.length;i++) cd.prefix[i]();\n            for(i=0;i<cd.watchers.length;i++) {\n                w = cd.watchers[i];\n                value = w.fn();\n                if(w.value !== value) {\n                    if(w.cmp) {\n                        changes += w.cmp(w, value);\n                    } else {\n                        w.value = value;\n                        if(!w.ro) changes++;\n                        w.cb(w.value);\n                    }\n                }\n            }            if(cd.children.length) queue.push.apply(queue, cd.children);\n            cd = queue[index++];\n        }\n        loop--;\n        if(!changes) break;\n    }\n    if(loop < 0) __app_onerror('Infinity changes: ', w);\n}\n\nlet templatecache = {};\nlet templatecacheSvg = {};\n\nlet $$uniqIndex = 1;\n\nconst childNodes = 'childNodes';\nconst firstChild = 'firstChild';\n\nlet noop = a => a;\n\nconst insertAfter = (label, node) => {\n    label.parentNode.insertBefore(node, label.nextSibling);\n};\n\nconst createTextNode = (text) => {\n    let f = document.createDocumentFragment();\n    f.append(text);\n    return f;\n};\n\nconst $$htmlToFragment = (html) => {\n    if(templatecache[html]) return templatecache[html].cloneNode(true);\n\n    let t = document.createElement('template');\n    t.innerHTML = html.replace(/<>/g, '<!---->');\n    let result = t.content;\n    templatecache[html] = result.cloneNode(true);\n    return result;\n};\n\nconst $$htmlToFragmentClean = (html) => {\n    if(templatecache[html]) return templatecache[html].cloneNode(true);\n\n    let t = document.createElement('template');\n    t.innerHTML = html.replace(/<>/g, '<!---->');\n    let result = t.content;\n\n    let it = document.createNodeIterator(result, 128);\n    let n;\n    while(n = it.nextNode()) {\n        if(!n.nodeValue) n.parentNode.replaceChild(document.createTextNode(''), n);\n    }    templatecache[html] = result.cloneNode(true);\n    return result;\n};\n\nfunction svgToFragment(content) {\n    if(templatecacheSvg[content]) return templatecacheSvg[content].cloneNode(true);\n    let t = document.createElement('template');\n    t.innerHTML = '<svg>' + content + '</svg>';\n\n    let result = document.createDocumentFragment();\n    let svg = t.content[firstChild];\n    while(svg[firstChild]) result.appendChild(svg[firstChild]);\n    templatecacheSvg[content] = result.cloneNode(true);\n    return result;\n}\nfunction $$removeElements(el, last) {\n    let next;\n    while(el) {\n        next = el.nextSibling;\n        el.remove();\n        if(el == last) break;\n        el = next;\n    }\n}\nfunction removeElementsBetween(el, stop) {\n    let next;\n    el = el.nextSibling;\n    while(el) {\n        next = el.nextSibling;\n        if(el == stop) break;\n        el.remove();\n        el = next;\n    }\n}\nconst getFinalLabel = n => {\n    if(n.nextSibling) return n.nextSibling;\n    let e = document.createTextNode('');\n    n.parentNode.appendChild(e);\n    return e;\n};\n\n\nlet _tick_list = [];\nlet _tick_planned = {};\nfunction $tick(fn, uniq) {\n    if(uniq) {\n        if(_tick_planned[uniq]) return;\n        _tick_planned[uniq] = true;\n    }\n    _tick_list.push(fn);\n    if(_tick_planned.$tick) return;\n    _tick_planned.$tick = true;\n    setTimeout(() => {\n        _tick_planned = {};\n        let list = _tick_list;\n        _tick_list = [];\n        list.map(safeCall);\n    }, 0);\n}\n\nfunction $makeEmitter(option) {\n    return (name, detail) => {\n        let fn = option.events[name];\n        if(!fn) return;\n        let e = document.createEvent('CustomEvent');\n        e.initCustomEvent(name, false, false, detail);\n        fn(e);\n    };\n}\n\nfunction $$addEventForComponent(list, event, fn) {\n    let prev = list[event];\n    if(prev) {\n        if(prev._list) prev._list.push(fn);\n        else {\n            function handler(e) {\n                handler._list.forEach(fn => {\n                    fn(e);\n                });\n            }\n            handler._list = [prev, fn];\n            list[event] = handler;\n        }\n    } else list[event] = fn;\n}\nfunction $$makeSpreadObject($cd, el, css) {\n    let prev = {};\n    let index = 0;\n    let list = [];\n    let defaultUsed = {};\n\n    const props = Object.getOwnPropertyDescriptors(el.__proto__);\n\n    const render = $$groupCall(function() {\n        let obj, name, value, used = Object.assign({}, defaultUsed);\n        for(let i=index-1; i>=0; i--) {\n            obj = list[i];\n            for(name in obj) {\n                if(used[name]) continue;\n                used[name] = true;\n                value = obj[name];\n                if(prev[name] == value) continue;\n                prev[name] = value;\n\n                if(props[name] && props[name].set) {\n                    el[name] = value;\n                } else {\n                    if(value == null) el.removeAttribute(name);\n                    else {\n                        if(name == 'class' && css) value += ' ' + css;\n                        el.setAttribute(name, value);\n                    }\n                }\n            }\n        }\n    });\n\n    return {\n        spread: function(fn) {\n            let i = index++;\n            $watch($cd, fn, value => {\n                list[i] = value;\n                render();\n            }, {ro: true, cmp: $$deepComparator(1)});\n        },\n        prop: function(name, fn) {\n            let i = index++;\n            list[i] = {};\n            $watch($cd, fn, value => {\n                list[i][name] = value;\n                render();\n            }, {ro: true});\n        },\n        attr: function(name, value) {\n            let d = {};\n            d[name] = value;\n            list[index++] = d;\n        },\n        except: function(list) {\n            list.forEach(n => defaultUsed[n] = true);\n        }\n    }\n}\n\nfunction $$groupCall(emit) {\n    let id = `gc${$$uniqIndex++}`;\n    const fn = function() {\n        $tick(() => {\n            fn.emit && fn.emit();\n        }, id);\n    };\n    fn.emit = emit;\n    return fn;\n}\nlet current_component, $context;\n\nconst $onDestroy = fn => current_component._d.push(fn);\nconst $onMount = fn => current_component._m.push(fn);\n\n\nconst $insertElementByOption = ($label, $option, $element) => {\n    if ($option.afterElement) {\n        insertAfter($label, $element);\n    } else {\n        $label.innerHTML = '';\n        $label.appendChild($element);\n    }\n};\n\n\nconst $readOnlyBase = {\n    a: ($component) => {\n        $component.$cd = {\n            _d: $component._d,\n            watchers: [],\n            prefix: [],\n            new: () => $component.$cd,\n            destroy: noop,\n            $$: $component\n        };\n    },\n    b: ($component) => {\n        let watchers = $component.$cd.watchers;\n        let prefix = $component.$cd.prefix;\n        while(watchers.length || prefix.length) {\n            let wl = watchers.slice();\n            watchers.length = 0;\n            prefix.forEach(safeCall);\n            prefix.length = 0;\n            wl.forEach(w => w.cb(w.fn()));\n        }\n    }\n};\n\n\nconst $base = {\n    a: ($component) => {\n        let $cd = new $ChangeDetector();\n        $cd.$$ = $component;\n        $onDestroy(() => $cd.destroy());\n\n        let id = `a${$$uniqIndex++}`;\n        let process;\n        let apply = r => {\n            if (process) return r;\n            $tick(() => {\n                try {\n                    process = true;\n                    $digest($cd);\n                } finally {\n                    process = false;\n                }\n            }, id);\n            return r;\n        };\n\n        $component.$cd = $cd;\n        $component.apply = apply;\n        $component.push = apply;\n    },\n    b: ($component) => {\n        $component.apply();\n    }\n};\n\n\nconst makeComponent = (init, $base) => {\n    return ($element, $option={}) => {\n        let prev = current_component;\n        $context = $option.context || {};\n        let $component = current_component = {\n            $option,\n            destroy: () => $component._d.map(safeCall),\n            context: $context,\n            exported: {},\n            _d: [],\n            _m: []\n        };\n        $base.a($component);\n\n        try {\n            $insertElementByOption($element, $option, init($option, $component.apply));\n            $base.b($component);\n        } finally {\n            current_component = prev;\n            $context = null;\n        }\n\n        $component._d.push(...$component._m.map(safeCall));\n        return $component;\n    };\n};\n\n\nconst callComponent = (cd, context, component, label, option, propFn, cmp, setter, classFn) => {\n    option.afterElement = true;\n    option.context = {...context};\n    let $component, parentWatch, childWatch;\n\n    if(propFn) {\n        if(cmp) {\n            parentWatch = $watch(cd, propFn, value => {\n                option.props = value;\n                if($component) {\n                    $component.push?.();\n                    childWatch && (childWatch.idle = true);\n                    $component.apply?.();\n                }\n            }, {ro: true, value: {}, cmp});\n            fire(parentWatch);\n        } else option.props = propFn();\n    }\n\n    if(classFn) {\n        fire($watch(cd, classFn, value => {\n            option.$class = value;\n            $component?.apply?.();\n        }, {ro: true, value: {}, cmp: keyComparator}));\n    }\n\n    $component = safeCall(() => component(label, option));\n    if($component) {\n      cd_onDestroy(cd, $component.destroy);\n\n      if(setter && $component.exportedProps) {\n        childWatch = $watch($component.$cd, $component.exportedProps, value => {\n          setter(value);\n          cd.$$.apply();\n        }, {ro: true, idle: true, value: parentWatch.value, cmp});\n      }\n    }\n    return $component;\n};\n\n\nconst autoSubscribe = (...list) => {\n    list.forEach(i => {\n        if(i.subscribe) {\n            let unsub = i.subscribe(current_component.apply);\n            if(isFunction(unsub)) cd_onDestroy(current_component, unsub);\n        }\n    });\n};\n\n\nconst addStyles = (id, content) => {\n    if(document.head.querySelector('style#' + id)) return;\n    let style = document.createElement('style');\n    style.id = id;\n    style.innerHTML = content;\n    document.head.appendChild(style);\n};\n\n\nconst addClass = (el, className) => el.classList.add(className);\n\n\nconst bindClass = (cd, element, fn, className) => {\n    $watchReadOnly(cd, fn, value => {\n        if(value) addClass(element, className);\n        else element.classList.remove(className);\n    });\n};\n\n\nconst setClassToElement = (element, value) => {\n    if(typeof element.className == 'string') element.className = value;\n    else element.className.baseVal = value;\n};\n\n\nconst bindText = (cd, element, fn) => {\n    $watchReadOnly(cd, () => '' + fn(), value => {\n        element.textContent = value;\n    });\n};\n\n\nconst bindStyle = (cd, element, name, fn) => {\n    $watchReadOnly(cd, fn, (value) => {\n        element.style[name] = value;\n    });\n};\n\n\nconst bindAttributeBase = (element, name, value) => {\n    if(value != null) element.setAttribute(name, value);\n    else element.removeAttribute(name);\n};\n\n\nconst bindAttribute = (cd, element, name, fn) => {\n    $watchReadOnly(cd, () => '' + fn(), value => bindAttributeBase(element, name, value));\n};\n\n\nconst bindAction = (cd, element, action, fn, subscribe) => {\n    $tick(() => {\n        let handler, value;\n        if(fn) {\n            value = fn();\n            handler = action.apply(null, [element].concat(value));\n        } else handler = action(element);\n        if(handler?.destroy) cd_onDestroy(cd, handler.destroy);\n        subscribe?.(cd, fn, handler, value);\n    });\n};\n\n\nconst __bindActionSubscribe = (cd, fn, handler, value) => {\n    if(handler?.update && fn) {\n        $watch(cd, fn, args => {\n            handler.update.apply(handler, args);\n        }, {cmp: $$deepComparator(1), value: cloneDeep(value, 1) });\n    }\n};\n\n\nconst bindInput = (cd, element, name, get, set) => {\n    let w = $watchReadOnly(cd, name == 'checked' ? () => !!get() : get, value => {\n        element[name] = value == null ? '' : value;\n    });\n    addEvent(cd, element, 'input', () => {\n        set(w.value = element[name]);\n    });\n};\n\n\nconst makeClassResolver = ($option, classMap, metaClass, mainName) => {\n    if(!$option.$class) $option.$class = {};\n    if(!mainName && metaClass.main) mainName = 'main';\n    return (line, defaults) => {\n        let result = [];\n        if(defaults) result.push(defaults);\n        line.trim().split(/\\s+/).forEach(name => {\n            let meta;\n            if(name[0] == '$') {\n                name = name.substring(1);\n                meta = true;\n            }\n            let h = metaClass[name] || meta;\n            if(h) {\n                let className = ($option.$class[name === mainName ? '$$main' : name] || '').trim();\n                if(className) {\n                    result.push(className);\n                } else if(h !== true) {\n                    result.push(name, h);\n                }\n            }\n            let h2 = classMap[name];\n            if(h2) {\n                result.push(name, h2);\n            } else if(!h) {\n                result.push(name);\n            }\n        });\n        return result.join(' ');\n    }\n};\n\n\nconst makeExternalProperty = ($component, name, getter, setter) => {\n    Object.defineProperty($component, name, {\n        get: getter,\n        set: v => {setter(v); $component.apply();}\n    });\n};\n\n\nconst attachSlotBase = ($context, $cd, slotName, label, props, placeholder) => {\n    let $slot = $cd.$$.$option.slots?.[slotName];\n    if($slot) $slot($cd, label, $context, props);\n    else placeholder && placeholder();\n};\n\n\nconst attachSlot = ($context, $cd, slotName, label, props, placeholder, cmp) => {\n    let $slot = $cd.$$.$option.slots?.[slotName];\n    if($slot) {\n        let resultProps = {}, push;\n        if(props) {\n            let setter = (k) => {\n                return v => {\n                    resultProps[k] = v;\n                    push?.();\n                }\n            };\n            for(let k in props) {\n                let v = props[k];\n                if(isFunction(v)) {\n                    fire($watch($cd, v, setter(k), {ro: true, cmp}));\n                } else resultProps[k] = v;\n            }\n        }\n        push = $slot($cd, label, $context, resultProps);\n    } else placeholder && placeholder();\n};\n\n\nconst makeSlot = (parentCD, fn) => {\n    return (callerCD, label, $context, props) => {\n        let $cd = parentCD.new();\n        cd_onDestroy(callerCD, () => $cd.destroy());\n        let r = fn($cd, $context, callerCD, props || {});\n        insertAfter(label, r.el || r);\n        $cd.$$.apply?.();\n        return r.push;\n    };\n};\n\n\nconst makeSlotStatic = (fn) => {\n    return (callerCD, label) => {\n        insertAfter(label, fn());\n    }\n};\n\n\nconst makeFragmentSlot = (parentCD, fn) => {\n    return (callerCD, label) => {\n        let $cd = parentCD.new();\n        cd_onDestroy(callerCD, () => $cd.destroy());\n        insertAfter(label, fn($cd));\n        $cd.$$.apply();\n    }\n};\n\n\nconst eachDefaultKey = (item, index, array) => typeof array[0] === 'object' ? item : index;\n\n\nconst attachAnchor = ($option, $cd, name, el) => {\n    let fn = $option.anchor && $option.anchor[name];\n    if(fn) cd_onDestroy($cd, fn(el));\n};\n\nfunction $$htmlBlock($cd, tag, fn) {\n    let lastElement;\n    let create = (html) => {\n        let fr;\n        if(tag.parentElement instanceof SVGElement) fr = svgToFragment(html);\n        else fr = $$htmlToFragment(html);\n        lastElement = fr.lastChild;\n        insertAfter(tag, fr);\n    };\n    let destroy = () => {\n        if(!lastElement) return;\n        let next, el = tag.nextSibling;\n        while(el) {\n            next = el.nextSibling;\n            el.remove();\n            if(el == lastElement) break;\n            el = next;\n        }\n\n        lastElement = null;\n    };\n    $watch($cd, fn, (html) => {\n        destroy();\n        if(html) create(html);\n    }, {ro: true});\n}\n\nfunction $$ifBlock($cd, $parentElement, fn, tpl, build, tplElse, buildElse) {\n    let childCD;\n    let first, last;\n\n    function create(fr, builder) {\n        childCD = $cd.new();\n        let tpl = fr.cloneNode(true);\n        builder(childCD, tpl);\n        first = tpl[firstChild];\n        last = tpl.lastChild;\n        insertAfter($parentElement, tpl);\n    }\n    function destroy() {\n        if(!childCD) return;\n        childCD.destroy();\n        childCD = null;\n        $$removeElements(first, last);\n        first = last = null;\n    }\n    $watch($cd, fn, (value) => {\n        if(value) {\n            destroy();\n            create(tpl, build);\n        } else {\n            destroy();\n            if(buildElse) create(tplElse, buildElse);\n        }\n    });\n}\n\nfunction $$awaitBlock($cd, label, relation, fn, $$apply, build_main, tpl_main, build_then, tpl_then, build_catch, tpl_catch) {\n    let promise, childCD;\n    let first, last, status = 0;\n\n    function remove() {\n        if(!childCD) return;\n        childCD.destroy();\n        childCD = null;\n        $$removeElements(first, last);\n        first = last = null;\n    }\n    function render(build, tpl, value) {\n        if(childCD) remove();\n        if(!tpl) return;\n        childCD = $cd.new();\n        let fr = tpl.cloneNode(true);\n        build(childCD, fr, value);\n        $$apply();\n        first = fr[firstChild];\n        last = fr.lastChild;\n        insertAfter(label, fr);\n    }\n    $watch($cd, relation, () => {\n        let p = fn();\n        if(status !== 1) render(build_main, tpl_main);\n        status = 1;\n        if(p && p instanceof Promise) {\n            promise = p;\n            promise.then(value => {\n                status = 2;\n                if(promise !== p) return;\n                render(build_then, tpl_then, value);\n            }).catch(value => {\n                status = 3;\n                if(promise !== p) return;\n                render(build_catch, tpl_catch, value);\n            });\n        }\n    }, {ro: true, cmp: $$deepComparator(1)});\n}\n\nfunction $$eachBlock($parentCD, label, onlyChild, fn, getKey, itemTemplate, bind) {\n    let $cd = $parentCD.new();\n\n    let mapping = new Map();\n    let lastNode;\n    let tplLength = itemTemplate[childNodes].length;\n\n    $watch($cd, fn, (array) => {\n        if(!array) array = [];\n        if(typeof(array) == 'number') array = [...Array(array)].map((_,i) => i + 1);\n        else if(!isArray(array)) array = [];\n\n        let newMapping = new Map();\n        let prevNode, parentNode;\n        if(onlyChild) {\n            prevNode = null;\n            parentNode = label;\n        } else {\n            prevNode = label;\n            parentNode = label.parentNode;\n        }\n\n        if(mapping.size) {\n            let ctx, count = 0;\n            for(let i=0;i<array.length;i++) {\n                ctx = mapping.get(getKey(array[i], i, array));\n                if(ctx) {\n                    ctx.a = true;\n                    count++;\n                }\n            }\n\n            if(!count && lastNode) {\n                if(onlyChild) label.textContent = '';\n                else $$removeElements(label.nextSibling, lastNode);\n                $cd.children.forEach(cd => cd.destroy(false));\n                $cd.children.length = 0;\n                mapping.clear();\n            } else {\n                $cd.children = [];\n                mapping.forEach(ctx => {\n                    if(ctx.a) {\n                        ctx.a = false;\n                        $cd.children.push(ctx.cd);\n                        return;\n                    }\n                    $$removeElements(ctx.first, ctx.last);\n                    ctx.cd.destroy(false);\n                });\n            }\n        }\n\n        let i, item, next_ctx, ctx, nextEl;\n        for(i=0;i<array.length;i++) {\n            item = array[i];\n            if(next_ctx) {\n                ctx = next_ctx;\n                next_ctx = null;\n            } else ctx = mapping.get(getKey(item, i, array));\n            if(ctx) {\n                nextEl = i == 0 && onlyChild ? parentNode[firstChild] : prevNode.nextSibling;\n                if(nextEl != ctx.first) {\n                    let insert = true;\n\n                    if(tplLength == 1 && (i + 1 < array.length) && prevNode && prevNode.nextSibling) {\n                        next_ctx = mapping.get(getKey(array[i + 1], i + 1, array));\n                        if(prevNode.nextSibling.nextSibling === next_ctx.first) {\n                            parentNode.replaceChild(ctx.first, prevNode.nextSibling);\n                            insert = false;\n                        }\n                    }\n\n                    if(insert) {\n                        let insertBefore = prevNode && prevNode.nextSibling;\n                        let next, el = ctx.first;\n                        while(el) {\n                            next = el.nextSibling;\n                            parentNode.insertBefore(el, insertBefore);\n                            if(el == ctx.last) break;\n                            el = next;\n                        }\n                    }\n                }\n                ctx.rebind(i, item);\n            } else {\n                let tpl = itemTemplate.cloneNode(true);\n                let childCD = $cd.new();\n                ctx = {cd: childCD};\n                bind(ctx, tpl, item, i);\n                ctx.first = tpl[firstChild];\n                ctx.last = tpl.lastChild;\n                parentNode.insertBefore(tpl, prevNode && prevNode.nextSibling);\n            }\n            prevNode = ctx.last;\n            newMapping.set(getKey(item, i, array), ctx);\n        }        lastNode = prevNode;\n        mapping.clear();\n        mapping = newMapping;\n    }, {ro: true, cmp: $$compareArray});\n}\n\nexport { $$addEventForComponent, $$awaitBlock, $$cloneDeep, $$compareArray, $$compareDeep, $$deepComparator, $$eachBlock, $$groupCall, $$htmlBlock, $$htmlToFragment, $$htmlToFragmentClean, $$ifBlock, $$makeSpreadObject, $$removeElements, $$removeItem, $ChangeDetector, $base, $context, $digest, $insertElementByOption, $makeEmitter, $onDestroy, $onMount, $readOnlyBase, $tick, $watch, $watchReadOnly, __app_onerror, __bindActionSubscribe, addClass, addEvent, addStyles, attachAnchor, attachSlot, attachSlotBase, autoSubscribe, bindAction, bindAttribute, bindAttributeBase, bindClass, bindInput, bindStyle, bindText, callComponent, cd_onDestroy, childNodes, cloneDeep, configure, createTextNode, current_component, eachDefaultKey, fire, firstChild, getFinalLabel, insertAfter, isArray, isFunction, keyComparator, makeClassResolver, makeComponent, makeExternalProperty, makeFragmentSlot, makeSlot, makeSlotStatic, noop, removeElementsBetween, setClassToElement, svgToFragment };\n", "import * as $runtime from 'malinajs/runtime.js';\nimport { $watch, $watchReadOnly, $tick } from 'malinajs/runtime.js';\nimport { $$htmlToFragment } from 'malinajs/runtime.js';\nexport default $runtime.makeComponent(($option, $$apply) => {\n  const $component = $runtime.current_component;\n  let name = \"world\";\n  var degrees;\n  {\n    let $cd = $component.$cd;\n    const $parentElement = $$htmlToFragment(`<img src=\"./malinajs.svg\" alt=\"Malina.js Logo\" class=\"m0qio7k\"/> <h1 class=\"m0qio7k\"> </h1> <div class=\"m0qio7k\"><input type=\"text\" class=\"m0qio7k\"/></div><div class=\"m0qio7k\"><a class=\"m0qio7k\">Check backend endpoint</a></div><div class=\"m0qio7k\"> Edit and save files in <code>src</code> directory to reload </div>`);\n    let el0 = $parentElement[$runtime.firstChild];\n    let el1 = $parentElement[$runtime.childNodes][2][$runtime.firstChild];\n    let el3 = $parentElement[$runtime.childNodes][4][$runtime.firstChild];\n    let el4 = $parentElement[$runtime.childNodes][5][$runtime.firstChild];\n    $runtime.bindStyle($cd, el0, 'transform', () => (`rotate(${degrees}deg)`));\n    $runtime.bindText($cd, el1, () => `Hello................................. `+(name)+`!`);\n    $runtime.bindInput($cd, el3, 'value', () => name, a2 => {name = a2; $$apply();});\n    $tick(() => {\n      let $element=el3;\n      $element.focus()\n      $$apply();\n    });\n    $runtime.bindAttribute($cd, el4, 'href', () => (`/hello/`+(name)));\n    $cd.prefix.push(() => {degrees = (name.length - 5) * 5;});\n    $runtime.addStyles('m0qio7k', `img.m0qio7k{display:block;width:200px;margin:60px auto;transition:0.2s}h1.m0qio7k,div.m0qio7k{text-align:center;min-width:300px;margin:40px auto}input.m0qio7k{font-size:24px}a.m0qio7k{color:#009615}`);\n    return $parentElement;\n  }\n}, $runtime.$base);\n", "import App from './App.xht';\nApp(document.body);"],
  "mappings": ";;AAAA,MAAI,gBAAgB,QAAQ;AAQ5B,MAAM,aAAa,QAAM,OAAO,MAAM;AAGtC,MAAM,WAAW,QAAM;AACnB,QAAI;AACA,aAAO,WAAW,OAAO;AAAA,aACpB,GAAP;AACE,oBAAc;AAAA;AAAA;AAItB,kBAAgB,IAAI,IAAI,UAAU,GAAG;AACjC,QAAG,CAAC;AAAG,UAAI;AACX,MAAE,KAAK;AACP,MAAE,KAAK;AACP,QAAG,CAAE,YAAW;AAAI,QAAE,QAAQ;AAC9B,OAAG,SAAS,KAAK;AACjB,WAAO;AAAA;AAEX,0BAAwB,IAAI,IAAI,UAAU;AACtC,WAAO,OAAO,IAAI,IAAI,UAAU,EAAC,IAAI;AAAA;AAEzC,oBAAkB,IAAI,IAAI,OAAO,UAAU;AACvC,OAAG,iBAAiB,OAAO;AAC3B,iBAAa,IAAI,MAAM;AACnB,SAAG,oBAAoB,OAAO;AAAA;AAAA;AAGtC,wBAAsB,IAAI,IAAI;AAC1B,QAAG;AAAI,SAAG,GAAG,KAAK;AAAA;AAEtB,wBAAsB,OAAO,MAAM;AAC/B,QAAI,IAAI,MAAM,QAAQ;AACtB,QAAG,KAAG;AAAG,YAAM,OAAO,GAAG;AAAA;AAE7B,2BAAyB,QAAQ;AAC7B,SAAK,SAAS;AACd,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,SAAK,KAAK;AACV,SAAK,SAAS;AACd,SAAK,KAAK,QAAQ;AAAA;AAEtB,kBAAgB,UAAU,MAAM,WAAW;AACvC,QAAI,KAAK,IAAI,gBAAgB;AAC7B,SAAK,SAAS,KAAK;AACnB,WAAO;AAAA;AAGX,kBAAgB,UAAU,UAAU,SAAS,QAAQ;AACjD,QAAG,WAAW,SAAS,KAAK;AAAQ,mBAAa,KAAK,OAAO,UAAU;AACvE,SAAK,SAAS,SAAS;AACvB,SAAK,OAAO,SAAS;AACrB,SAAK,GAAG,IAAI;AACZ,SAAK,GAAG,SAAS;AACjB,SAAK,SAAS,IAAI,QAAM,GAAG,QAAQ;AACnC,SAAK,SAAS,SAAS;AAAA;AAI3B,MAAM,UAAU,CAAC,MAAM,MAAM,QAAQ;AAuBrC,MAAM,cAAc,CAAC,GAAG,GAAG,QAAQ;AAC/B,QAAG,MAAM,KAAK,CAAC,KAAK,CAAC;AAAG,aAAO,MAAM;AACrC,QAAG,MAAM;AAAG,aAAO;AACnB,QAAI,KAAK,OAAO,KAAM;AACtB,QAAI,KAAK,OAAO,KAAM;AACtB,QAAG,CAAE,OAAM;AAAK,aAAO,MAAM;AAE7B,QAAI,KAAK,QAAQ;AACjB,QAAI,KAAK,QAAQ;AACjB,QAAG,OAAO;AAAI,aAAO;AAErB,QAAG,IAAI;AACH,UAAG,EAAE,WAAW,EAAE;AAAQ,eAAO;AACjC,eAAQ,IAAE,GAAE,IAAE,EAAE,QAAO,KAAK;AACxB,YAAG,YAAY,EAAE,IAAI,EAAE,IAAI,MAAI;AAAI,iBAAO;AAAA;AAAA,WAE3C;AACH,UAAI,MAAM;AACV,eAAQ,KAAK,GAAG;AACZ,YAAG,YAAY,EAAE,IAAI,EAAE,IAAI,MAAI;AAAI,iBAAO;AAC1C,YAAI,KAAK;AAAA;AAEb,eAAQ,KAAK,GAAG;AACZ,YAAG,IAAI;AAAI;AACX,eAAO;AAAA;AAAA;AAIf,WAAO;AAAA;AAGX,qBAAmB,GAAG,KAAK;AACvB,QAAG,MAAM,KAAK,CAAC;AAAG,aAAO;AAEzB,QAAG,OAAO,KAAM,UAAU;AACtB,UAAG,aAAa;AAAM,eAAO;AAC7B,UAAG,aAAa;AAAS,eAAO;AAChC,UAAG,QAAQ;AAAI,eAAO,EAAE,IAAI,OAAK,UAAU,GAAG,MAAI;AAClD,UAAI,IAAI;AACR,eAAQ,KAAK;AAAG,UAAE,KAAK,UAAU,EAAE,IAAI,MAAI;AAC3C,aAAO;AAAA;AAEX,WAAO;AAAA;AAMX,4BAA0B,OAAO;AAC7B,WAAO,SAAS,GAAG,OAAO;AACtB,UAAI,OAAO,YAAY,EAAE,OAAO,OAAO;AACvC,cAAS,GAAE,QAAQ,UAAU,OAAO,QAAQ,CAAC,EAAE,QAAQ,EAAE,GAAG;AAC5D,QAAE,OAAO;AACT,aAAO,CAAC,EAAE,MAAM,OAAO,IAAI;AAAA;AAAA;AAGnC,MAAM,gBAAgB,iBAAiB;AAuBvC,mBAAiB,KAAK;AAClB,QAAI,OAAO;AACX,QAAI;AACJ,WAAM,QAAQ,GAAG;AACb,UAAI,UAAU;AACd,UAAI,QAAQ;AACZ,UAAI,QAAQ;AACZ,UAAI,GAAG,OAAO,KAAK;AACnB,aAAM,IAAI;AACN,aAAI,IAAE,GAAE,IAAE,GAAG,OAAO,QAAO;AAAK,aAAG,OAAO;AAC1C,aAAI,IAAE,GAAE,IAAE,GAAG,SAAS,QAAO,KAAK;AAC9B,cAAI,GAAG,SAAS;AAChB,kBAAQ,EAAE;AACV,cAAG,EAAE,UAAU,OAAO;AAClB,gBAAG,EAAE,KAAK;AACN,yBAAW,EAAE,IAAI,GAAG;AAAA,mBACjB;AACH,gBAAE,QAAQ;AACV,kBAAG,CAAC,EAAE;AAAI;AACV,gBAAE,GAAG,EAAE;AAAA;AAAA;AAAA;AAGN,YAAG,GAAG,SAAS;AAAQ,gBAAM,KAAK,MAAM,OAAO,GAAG;AAC/D,aAAK,MAAM;AAAA;AAEf;AACA,UAAG,CAAC;AAAS;AAAA;AAEjB,QAAG,OAAO;AAAG,oBAAc,sBAAsB;AAAA;AAGrD,MAAI,gBAAgB;AAGpB,MAAI,cAAc;AAElB,MAAM,aAAa;AACnB,MAAM,aAAa;AAInB,MAAM,cAAc,CAAC,OAAO,SAAS;AACjC,UAAM,WAAW,aAAa,MAAM,MAAM;AAAA;AAS9C,MAAM,mBAAmB,CAAC,SAAS;AAC/B,QAAG,cAAc;AAAO,aAAO,cAAc,MAAM,UAAU;AAE7D,QAAI,IAAI,SAAS,cAAc;AAC/B,MAAE,YAAY,KAAK,QAAQ,OAAO;AAClC,QAAI,SAAS,EAAE;AACf,kBAAc,QAAQ,OAAO,UAAU;AACvC,WAAO;AAAA;AAwDX,MAAI,aAAa;AACjB,MAAI,gBAAgB;AACpB,iBAAe,IAAI,MAAM;AACrB,QAAG,MAAM;AACL,UAAG,cAAc;AAAO;AACxB,oBAAc,QAAQ;AAAA;AAE1B,eAAW,KAAK;AAChB,QAAG,cAAc;AAAO;AACxB,kBAAc,QAAQ;AACtB,eAAW,MAAM;AACb,sBAAgB;AAChB,UAAI,OAAO;AACX,mBAAa;AACb,WAAK,IAAI;AAAA,OACV;AAAA;AAiGP,MAAI;AAAJ,MAAuB;AAEvB,MAAM,aAAa,QAAM,kBAAkB,GAAG,KAAK;AAInD,MAAM,yBAAyB,CAAC,QAAQ,SAAS,aAAa;AAC1D,QAAI,QAAQ,cAAc;AACtB,kBAAY,QAAQ;AAAA,WACjB;AACH,aAAO,YAAY;AACnB,aAAO,YAAY;AAAA;AAAA;AA8B3B,MAAM,QAAQ;AAAA,IACV,GAAG,CAAC,eAAe;AACf,UAAI,MAAM,IAAI;AACd,UAAI,KAAK;AACT,iBAAW,MAAM,IAAI;AAErB,UAAI,KAAK,IAAI;AACb,UAAI;AACJ,UAAI,QAAQ,OAAK;AACb,YAAI;AAAS,iBAAO;AACpB,cAAM,MAAM;AACR,cAAI;AACA,sBAAU;AACV,oBAAQ;AAAA,oBACV;AACE,sBAAU;AAAA;AAAA,WAEf;AACH,eAAO;AAAA;AAGX,iBAAW,MAAM;AACjB,iBAAW,QAAQ;AACnB,iBAAW,OAAO;AAAA;AAAA,IAEtB,GAAG,CAAC,eAAe;AACf,iBAAW;AAAA;AAAA;AAKnB,MAAM,gBAAgB,CAAC,MAAM,WAAU;AACnC,WAAO,CAAC,UAAU,UAAQ,OAAO;AAC7B,UAAI,OAAO;AACX,iBAAW,QAAQ,WAAW;AAC9B,UAAI,aAAa,oBAAoB;AAAA,QACjC;AAAA,QACA,SAAS,MAAM,WAAW,GAAG,IAAI;AAAA,QACjC,SAAS;AAAA,QACT,UAAU;AAAA,QACV,IAAI;AAAA,QACJ,IAAI;AAAA;AAER,aAAM,EAAE;AAER,UAAI;AACA,+BAAuB,UAAU,SAAS,KAAK,SAAS,WAAW;AACnE,eAAM,EAAE;AAAA,gBACV;AACE,4BAAoB;AACpB,mBAAW;AAAA;AAGf,iBAAW,GAAG,KAAK,GAAG,WAAW,GAAG,IAAI;AACxC,aAAO;AAAA;AAAA;AAwDf,MAAM,YAAY,CAAC,IAAI,YAAY;AAC/B,QAAG,SAAS,KAAK,cAAc,WAAW;AAAK;AAC/C,QAAI,QAAQ,SAAS,cAAc;AACnC,UAAM,KAAK;AACX,UAAM,YAAY;AAClB,aAAS,KAAK,YAAY;AAAA;AAqB9B,MAAM,WAAW,CAAC,IAAI,SAAS,OAAO;AAClC,mBAAe,IAAI,MAAM,KAAK,MAAM,WAAS;AACzC,cAAQ,cAAc;AAAA;AAAA;AAK9B,MAAM,YAAY,CAAC,IAAI,SAAS,MAAM,OAAO;AACzC,mBAAe,IAAI,IAAI,CAAC,UAAU;AAC9B,cAAQ,MAAM,QAAQ;AAAA;AAAA;AAK9B,MAAM,oBAAoB,CAAC,SAAS,MAAM,UAAU;AAChD,QAAG,SAAS;AAAM,cAAQ,aAAa,MAAM;AAAA;AACxC,cAAQ,gBAAgB;AAAA;AAIjC,MAAM,gBAAgB,CAAC,IAAI,SAAS,MAAM,OAAO;AAC7C,mBAAe,IAAI,MAAM,KAAK,MAAM,WAAS,kBAAkB,SAAS,MAAM;AAAA;AA0BlF,MAAM,YAAY,CAAC,IAAI,SAAS,MAAM,KAAK,QAAQ;AAC/C,QAAI,IAAI,eAAe,IAAI,QAAQ,YAAY,MAAM,CAAC,CAAC,QAAQ,KAAK,WAAS;AACzE,cAAQ,QAAQ,SAAS,OAAO,KAAK;AAAA;AAEzC,aAAS,IAAI,SAAS,SAAS,MAAM;AACjC,UAAI,EAAE,QAAQ,QAAQ;AAAA;AAAA;;;AC9mB9B,MAAO,cAAQ,AAAS,cAAc,CAAC,SAAS,YAAY;AAC1D,UAAM,aAAsB;AAC5B,QAAI,OAAO;AACX,QAAI;AACJ;AACE,UAAI,MAAM,WAAW;AACrB,YAAM,iBAAiB,iBAAiB;AACxC,UAAI,MAAM,eAAwB;AAClC,UAAI,MAAM,eAAwB,YAAY,GAAY;AAC1D,UAAI,MAAM,eAAwB,YAAY,GAAY;AAC1D,UAAI,MAAM,eAAwB,YAAY,GAAY;AAC1D,MAAS,UAAU,KAAK,KAAK,aAAa,MAAO,UAAU;AAC3D,MAAS,SAAS,KAAK,KAAK,MAAM,4CAA2C,OAAM;AACnF,MAAS,UAAU,KAAK,KAAK,SAAS,MAAM,MAAM,QAAM;AAAC,eAAO;AAAI;AAAA;AACpE,YAAM,MAAM;AACV,YAAI,WAAS;AACb,iBAAS;AACT;AAAA;AAEF,MAAS,cAAc,KAAK,KAAK,QAAQ,MAAO,YAAW;AAC3D,UAAI,OAAO,KAAK,MAAM;AAAC,kBAAW,MAAK,SAAS,KAAK;AAAA;AACrD,MAAS,UAAU,WAAW;AAC9B,aAAO;AAAA;AAAA,KAEC;;;AC1BZ,cAAI,SAAS;",
  "names": []
}
